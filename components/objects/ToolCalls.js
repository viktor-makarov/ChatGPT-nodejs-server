const modelConfig = require("../../config/modelConfig");
const toolsCollection = require("./toolsCollection.js");
const mongo = require("../mongo");
const telegramErrorHandler = require("../telegramErrorHandler.js");

const FunctionCall  = require("./FunctionCall.js");

class ToolCalls{

    #replyMsg;
    #requestMsg;
    #user;
    #dialogue;
    #available_for_tool_calls;
    #tool_choice = "auto"
    #overalTokenLimit;
    #tokenFetchLimitPcs = (appsettings?.functions_options?.fetch_text_limit_pcs ? appsettings?.functions_options?.fetch_text_limit_pcs : 80)/100;

    constructor(obj) {
     this.#replyMsg = obj.replyMsgInstance;
     this.#user = obj.userInstance;
     this.#requestMsg = obj.requestMsgInstance;
     this.#dialogue = obj.dialogueInstance
     this.#overalTokenLimit = this.#user?.currentModel ? modelConfig[this.#user.currentModel]?.request_length_limit_in_tokens : null
     
    }

get tool_choice(){
    return this.#tool_choice
}

async router(toolCalls = []){

    try{
    if(toolCalls.length === 0){
        return;
    }

    const curentTokenLimit = (this.#overalTokenLimit- await this.#dialogue.metaGetTotalTokens())*this.#tokenFetchLimitPcs;
    const tokensLimitPerCall = curentTokenLimit/toolCalls.length;

    const toolCallsPromiseList =  toolCalls.map(async (toolCall, index) =>  {

        const tool_config = await toolsCollection.toolConfigByFunctionName(toolCall?.function?.name,this.#user)
        
        //Here we change structure of the external object just in case it will chnage in future.
        const toolCallExtended = {
            tool_call_id:toolCall.id,
            tool_call_index:toolCall.index,
            tool_call_type:toolCall.type,
            function_name:toolCall?.function?.name,
            function_arguments:toolCall?.function?.arguments,
            tool_config
        };

        let toolResult = {
            tool_call_id:toolCall.id,
            function_name:toolCall?.function?.name
        }

        await this.#dialogue.preCommitToolReply(toolCallExtended)

        if(toolCallExtended.tool_call_type === "function"){
            
            const functionInstance = new FunctionCall({
                functionCall:toolCallExtended,
                replyMsgInstance:this.#replyMsg,
                dialogueInstance:this.#dialogue,
                requestMsgInstance:this.#requestMsg,
                tokensLimitPerCall:tokensLimitPerCall
            });

            let outcome = await functionInstance.router();

            toolResult.content = JSON.stringify(outcome)
            toolResult.success = outcome.success
            toolResult.duration = outcome.duration || 0;
            toolResult.image_url = outcome.small_image_url
            toolResult.midjourney_prompt = outcome.midjourney_prompt
                           
        } else {
            const outcome = {success:0,error:"Non-function types cannot be processed for now.",instructions:"Rework into a function"}
            toolResult.content = JSON.stringify(outcome)
            toolResult.success = outcome.success
        }

        await this.#dialogue.updateCommitToolReply(toolResult)

        if(toolResult.function_name==="create_midjourney_image" && toolResult.image_url){
            const fileComment = {
                midjourney_prompt:toolResult.midjourney_prompt,
                public_url:toolResult.image_url,
                context:"Image has been generated by 'create_midjourney_image' function",
            }
            await this.#dialogue.commitImageToDialogue(toolResult.image_url,fileComment)
        }
               
        await mongo.insertFunctionUsagePromise({
            userInstance:this.#user,
            tool_function:toolResult.function_name,
            tool_reply:toolResult,
            call_duration:toolResult.duration,
            call_number:`${index}/${toolCallsPromiseList.length}`,
            success:toolResult.success
        })

        return toolResult;
    });

        try{
            await this.#dialogue.metaSetAllFunctionsInProgressStatus(true)
            await Promise.all(toolCallsPromiseList)
        } finally{
            await this.#dialogue.metaSetAllFunctionsInProgressStatus(false)
        }

        this.#dialogue.emit('callCompletion');

    } catch (err){
      err.mongodblog = err.mongodblog || true
      err.place_in_code = err.place_in_code || "toolcalls.router";
      telegramErrorHandler.main(
        {
          replyMsgInstance:this.#replyMsg,
          error_object:err
        }
      );
    
    }
};

async addMsgIdToToolCall(toolCallId,systemMsgId){

    await mongo.updateCompletionInDb({
        filter: {"tool_calls.id":toolCallId},       
        updateBody:{ "tool_calls.$.telegramMsgId": systemMsgId }
      })
}

};
    
module.exports = ToolCalls;