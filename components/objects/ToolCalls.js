const modelConfig = require("../../config/modelConfig");
const toolsCollection = require("./toolsCollection.js");
const mongo = require("../mongo");
const telegramErrorHandler = require("../telegramErrorHandler.js");

const FunctionCall  = require("./FunctionCall.js");

class ToolCalls{

    #replyMsg;
    #requestMsg;
    #user;
    #dialogue;
    #available_for_tool_calls;
    #tool_choice = "auto"
    #overalTokenLimit;
    #tokenFetchLimitPcs = (appsettings?.functions_options?.fetch_text_limit_pcs ? appsettings?.functions_options?.fetch_text_limit_pcs : 80)/100;

    constructor(obj) {
     this.#replyMsg = obj.replyMsgInstance;
     this.#user = obj.userInstance;
     this.#requestMsg = obj.requestMsgInstance;
     this.#dialogue = obj.dialogueInstance
     this.#overalTokenLimit = this.#user?.currentModel ? modelConfig[this.#user.currentModel]?.request_length_limit_in_tokens : null
     
    }

get tool_choice(){
    return this.#tool_choice
}

async router(toolCalls = []){

    try{
    if(toolCalls.length === 0){
        return;
    }

    const currentTokenLimit = (this.#overalTokenLimit- await this.#dialogue.metaGetTotalTokens())*this.#tokenFetchLimitPcs;
    const tokensLimitPerCall = currentTokenLimit/toolCalls.length;

    const toolCallsPromiseList =  toolCalls.map(async (toolCall, index) =>  {

        const tool_config = await toolsCollection.toolConfigByFunctionName(toolCall?.function?.name,this.#user)
        const functionName = toolCall?.function?.name;
        const toolId = toolCall.id;
        let mdj_public_url;
        let mdj_prompt;


        //Here we change structure of the external object just in case it will chnage in future.
        const toolCallExtended = {
            tool_call_id:toolCall.id,
            tool_call_index:toolCall.index,
            tool_call_type:toolCall.type,
            function_name:functionName,
            function_arguments:toolCall?.function?.arguments,
            tool_config
        };

        let toolExecutionResult = {
            tool_call_id:toolId,
            function_name:toolCall?.function?.name
        }

        await this.#dialogue.preCommitToolReply(toolCallExtended)

        let outcome;
        if(toolCallExtended.tool_call_type === "function"){
            
            const functionInstance = new FunctionCall({
                functionCall:toolCallExtended,
                replyMsgInstance:this.#replyMsg,
                dialogueInstance:this.#dialogue,
                requestMsgInstance:this.#requestMsg,
                tokensLimitPerCall:tokensLimitPerCall
            });

            outcome = await functionInstance.router();

            mdj_public_url = outcome?.supportive_data?.image_url;
            mdj_prompt = outcome?.supportive_data?.midjourney_prompt;
            toolExecutionResult.success = outcome.success
            toolExecutionResult.duration = outcome?.supportive_data?.duration || 0;
            outcome?.supportive_data && delete outcome.supportive_data;
            toolExecutionResult.content = JSON.stringify(outcome)
                           
        } else {
            const outcome = {success:0,error:"Non-function types cannot be processed for now.",instructions:"Rework into a function"}
            toolExecutionResult.content = JSON.stringify(outcome)
            toolExecutionResult.success = outcome.success
        }

        await this.#dialogue.updateCommitToolReply(toolExecutionResult)

        if(functionName==="create_midjourney_image" && mdj_public_url){
            const fileComment = {
                midjourney_prompt:mdj_prompt,
                public_url:mdj_public_url,
                context:"Image has been generated by 'create_midjourney_image' function",
            }
            await this.#dialogue.commitImageToDialogue(mdj_public_url,fileComment)
        }
        
        await mongo.insertFunctionUsagePromise({
            userInstance:this.#user,
            tool_function:functionName,
            tool_reply:toolExecutionResult,
            call_duration:toolExecutionResult.duration,
            call_number:`${index}/${toolCallsPromiseList.length}`,
            success:toolExecutionResult.success
        })

        return toolExecutionResult;
    });

        try{
            await this.#dialogue.metaSetAllFunctionsInProgressStatus(true)
            await Promise.all(toolCallsPromiseList)
        } finally{
            await this.#dialogue.metaSetAllFunctionsInProgressStatus(false)
        }

        this.#dialogue.emit('callCompletion');

    } catch (err){
      err.mongodblog = err.mongodblog || true
      err.place_in_code = err.place_in_code || "toolcalls.router";
      telegramErrorHandler.main(
        {
          replyMsgInstance:this.#replyMsg,
          error_object:err
        }
      );
    
    }
};

async addMsgIdToToolCall(toolCallId,systemMsgId){

    await mongo.updateCompletionInDb({
        filter: {"tool_calls.id":toolCallId},       
        updateBody:{ "tool_calls.$.telegramMsgId": systemMsgId }
      })
}

};
    
module.exports = ToolCalls;